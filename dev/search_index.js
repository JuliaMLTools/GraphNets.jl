var documenterSearchIndex = {"docs":
[{"location":"#GraphNets.jl","page":"GraphNets.jl","title":"GraphNets.jl","text":"","category":"section"},{"location":"","page":"GraphNets.jl","title":"GraphNets.jl","text":"CurrentModule = GraphNets","category":"page"},{"location":"#Simple,-blazing-fast,-graph-neural-network-components.","page":"GraphNets.jl","title":"Simple, blazing fast, graph neural network components.","text":"","category":"section"},{"location":"","page":"GraphNets.jl","title":"GraphNets.jl","text":"GraphNets.jl is a Julia implementation of DeepMind's Graph Nets and an implementation of the following paper: Relational inductive biases, deep learning, and graph networks","category":"page"},{"location":"","page":"GraphNets.jl","title":"GraphNets.jl","text":"Petar Veličković gives a fantastic explanation of the Graph Nets architecture and graph neural networks in general in the lecture below.","category":"page"},{"location":"","page":"GraphNets.jl","title":"GraphNets.jl","text":"<iframe style=\"width:100%;height:500px\" src=\"https://www.youtube.com/embed/i79ewWQiUX4\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>","category":"page"},{"location":"#Setup","page":"GraphNets.jl","title":"Setup","text":"","category":"section"},{"location":"","page":"GraphNets.jl","title":"GraphNets.jl","text":"using GraphNets\n\nX_DE = 10 # Input feature dimension of edges\nX_DN = 5 # Input feature dimension of nodes\nX_DG = 0 # Input feature dimension of graphs (no graph level input data)\nY_DE = 3 # Output feature dimension of edges\nY_DN = 4 # Output feature dimension of nodes\nY_DG = 5 # Output feature dimension of graphs\n\nblock = GNBlock(\n    (X_DE,X_DN,X_DG) => (Y_DE,Y_DN,Y_DG)\n)","category":"page"},{"location":"#Example-1:-Batch-of-graphs-with-same-structure-(same-adjacency-matrix)","page":"GraphNets.jl","title":"Example 1: Batch of graphs with same structure (same adjacency matrix)","text":"","category":"section"},{"location":"","page":"GraphNets.jl","title":"GraphNets.jl","text":"adj_mat = [\n    1 0 1;\n    1 1 0;\n    0 0 1;\n] # Adjacency matrix\n\nnum_nodes = size(adj_mat, 1)\nnum_edges = length(filter(isone, adj_mat))\n\nbatch_size = 2\nedge_features = rand(Float32, X_DE, num_edges, batch_size)\nnode_features = rand(Float32, X_DN, num_nodes, batch_size)\ngraph_features = nothing # no graph level input features\n\nx = (\n    graphs=adj_mat, # All graphs in this batch have same structure\n    ef=edge_features, # (X_DE, num_edges, batch_size)\n    nf=node_features, # (X_DN, num_nodes, batch_size)\n    gf=graph_features # (X_DG, batch_size)\n) |> batch\n\ny = block(x) |> unbatch\n\n@assert size(y.ef) == (Y_DE, num_edges, batch_size)\n@assert size(y.nf) == (Y_DN, num_nodes, batch_size)\n@assert size(y.gf) == (Y_DG, batch_size)\n\n# Get the output graph edges of the 1st graph\n@assert size(y.ef[:,:,1]) == (Y_DE, num_edges)\n\n# Get the output node edges of the 1st graph\n@assert size(y.nf[:,:,1]) == (Y_DN, num_nodes)\n\n# Get the output graph edges of the 2nd graph\n@assert size(y.gf[:,2]) == (Y_DG,)","category":"page"},{"location":"#Example-2:-Batch-of-graphs-with-different-structures","page":"GraphNets.jl","title":"Example 2: Batch of graphs with different structures","text":"","category":"section"},{"location":"","page":"GraphNets.jl","title":"GraphNets.jl","text":"adj_mat_1 = [\n    1 0 1;\n    1 1 0;\n    0 0 1;\n] # Adjacency matrix 1\nnum_nodes_1 = size(adj_mat_1, 1)\nnum_edges_1 = length(filter(isone, adj_mat_1))\n\nadj_mat_2 = [\n    1 0 1 0;\n    1 1 0 1;\n    0 0 1 0;\n    1 1 0 1;\n] # Adjacency matrix 2\nnum_nodes_2 = size(adj_mat_2, 1)\nnum_edges_2 = length(filter(isone, adj_mat_2))\n\nedge_features = [\n    rand(Float32, X_DE, num_edges_1),\n    rand(Float32, X_DE, num_edges_2),\n]\nnode_features = [\n    rand(Float32, X_DN, num_nodes_1),\n    rand(Float32, X_DN, num_nodes_2),\n]\ngraph_features = nothing # no graph level input features\n\nx = (\n    graphs=[adj_mat_1,adj_mat_2],  # Graphs in this batch have different structure\n    ef=edge_features, \n    nf=node_features,\n    gf=graph_features\n) |> batch\n\ny_batched = block(x)\ny = y_batched |> unbatch\n\n# Memory-efficient view of features for a batch with different graph structures\n@assert size(efview(y_batched, :, :, 1)) == (Y_DE, num_edges_1) # edge features for graph 1\n@assert size(nfview(y_batched, :, :, 1)) == (Y_DN, num_nodes_1)  # edge features for graph 1\n@assert size(gfview(y_batched, :, 1)) == (Y_DG,) # graph features for graph 1\n@assert size(efview(y_batched, :, :, 2)) == (Y_DE, num_edges_2) # edge features for graph 2\n@assert size(nfview(y_batched, :, :, 2)) == (Y_DN, num_nodes_2) # node features for graph 2\n@assert size(gfview(y_batched, :, 2)) == (Y_DG,) # graph features for graph 2\n\n# Copied array of features (less efficient) for a batch with different graph structures\n@assert size(y.ef[1]) == (Y_DE, num_edges_1) # edge features for graph 1\n@assert size(y.nf[1]) == (Y_DN, num_nodes_1)  # edge features for graph 1\n@assert size(y.gf[1]) == (Y_DG,) # graph features for graph 1\n@assert size(y.ef[2]) == (Y_DE, num_edges_2) # edge features for graph 2\n@assert size(y.nf[2]) == (Y_DN, num_nodes_2) # node features for graph 2\n@assert size(y.gf[2]) == (Y_DG,) # graph features for graph 2","category":"page"},{"location":"#Example-3:-Encoder-Core-Decoder-(sequential-blocks)","page":"GraphNets.jl","title":"Example 3: Encoder -> Core -> Decoder (sequential blocks)","text":"","category":"section"},{"location":"","page":"GraphNets.jl","title":"GraphNets.jl","text":"input_dims = (X_DE, X_DN, X_DG)\ncore_dims = (10, 5, 3)\noutput_dims = (Y_DE, Y_DN, Y_DG)\n\nstruct GNNModel{E,C,D}\n    encoder::E\n    core_list::C\n    decoder::D\nend\n\nfunction GNNModel(; n_cores=2)\n    GNNModel(\n        GNBlock(input_dims => core_dims),\n        GNCoreList([GNCore(core_dims) for _ in 1:n_cores]),\n        GNBlock(core_dims => output_dims),\n    )\nend\n\nfunction (m::GNNModel)(x)\n    (m.decoder ∘ m.core_list ∘ m.encoder)(x)\nend\n\nm = GNNModel()\n\nadj_mat = [\n    1 0 1;\n    1 1 0;\n    0 0 1;\n]\n\nnum_nodes = size(adj_mat, 1)\nnum_edges = length(filter(isone, adj_mat))\n\nbatch_size = 2\nedge_features = rand(Float32, X_DE, num_edges, batch_size)\nnode_features = rand(Float32, X_DN, num_nodes, batch_size)\ngraph_features = nothing # no graph level input features\n\nx = (\n    graphs=adj_mat, # All graphs in this batch have same structure\n    ef=edge_features, # (X_DE, num_edges, batch_size)\n    nf=node_features, # (X_DN, num_nodes, batch_size)\n    gf=graph_features # (X_DG, batch_size)\n) |> batch\n\ny = block(x) |> unbatch\n\n@assert size(y.ef) == (Y_DE, num_edges, batch_size)\n@assert size(y.nf) == (Y_DN, num_nodes, batch_size)\n@assert size(y.gf) == (Y_DG, batch_size)","category":"page"},{"location":"#API-index","page":"GraphNets.jl","title":"API index","text":"","category":"section"},{"location":"","page":"GraphNets.jl","title":"GraphNets.jl","text":"","category":"page"},{"location":"#Components","page":"GraphNets.jl","title":"Components","text":"","category":"section"},{"location":"","page":"GraphNets.jl","title":"GraphNets.jl","text":"GraphNets.GNBlock\nGraphNets.GNCore\nGraphNets.GNCoreList\nGraphNets.batch\nGraphNets.unbatch\nGraphNets.efview\nGraphNets.nfview\nGraphNets.gfview","category":"page"},{"location":"#GraphNets.GNBlock","page":"GraphNets.jl","title":"GraphNets.GNBlock","text":"GNBlock(in => out;  dropout=0)\n\nInitializes an instance of the GNBlock type, representing a GraphNet block.\n\nA GNBlock instance accepts an input array x of dimensions (C, T, B) and outputs an array of dimensions (HS, T, B). \"C\" is the channel size (embedding dimension). \"T\" is the block size (number of input tokens). \"B\" is the batch size.\n\nThe following keyword arguments are supported:\n\ndropout (Defaults to 0)\n\nExample:\n\nin_dims = (X_DE, X_DN, X_DG) = 10, 5, 0\nout_dims = (Y_DE, Y_DN, Y_DG) = 3, 4, 5\nblock = GNBlock(in_dims => out_dims)\nadj_mat = adj_mat = [\n    1 0 1;\n    1 1 0;\n    0 0 1;\n]\nnum_nodes = size(adj_mat, 1)\nnum_edges = length(filter(isone, adj_mat))\nbatch_size = 2\nedge_features = rand(Float32, X_DE, num_edges, batch_size)\nnode_features = rand(Float32, X_DN, num_nodes, batch_size)\ngraph_features = nothing # no graph level input features\nx = (\n    graphs=adj_mat, # All graphs in this batch have same structure\n    ef=edge_features, # (X_DE, num_edges, batch_size)\n    nf=node_features, # (X_DN, num_nodes, batch_size)\n    gf=graph_features # no input graph features\n) |> batch\ny = block(x) |> unbatch\n@assert size(y.ef) == (Y_DE, num_edges, batch_size)\n@assert size(y.nf) == (Y_DN, num_nodes, batch_size)\n@assert size(y.gf) == (Y_DG, batch_size)\n\n\n\n\n\n","category":"type"},{"location":"#GraphNets.GNCore","page":"GraphNets.jl","title":"GraphNets.GNCore","text":"GNCore(dims; dropout=0)\n\nInitializes an instance of the GNCore type, representing a GraphNet \"core\" block.\n\nA GNCore instance accepts an input array x of dimensions (C, T, B) and outputs an array of dimensions (HS, T, B). \"C\" is the channel size (embedding dimension). \"T\" is the block size (number of input tokens). \"B\" is the batch size.\n\nThe following keyword arguments are supported:\n\ndropout (Defaults to 0)\n\nExamples:\n\ndims = (DE, DN, DG) = 3, 4, 5\ncore = GNCore(dims)\nadj_mat = adj_mat = [\n    1 0 1;\n    1 1 0;\n    0 0 1;\n]\nnum_nodes = size(adj_mat, 1)\nnum_edges = length(filter(isone, adj_mat))\nbatch_size = 2\nedge_features = rand(Float32, DE, num_edges, batch_size)\nnode_features = rand(Float32, DN, num_nodes, batch_size)\ngraph_features = rand(Float32, DG, batch_size)\nx = (\n    graphs=adj_mat, # All graphs in this batch have same structure\n    ef=edge_features, # (DE, num_edges, batch_size)\n    nf=node_features, # (DN, num_nodes, batch_size)\n    gf=graph_features # no input graph features\n) |> batch\ny = core(x) |> unbatch\n@assert size(y.ef) == (DE, num_edges, batch_size)\n@assert size(y.nf) == (DN, num_nodes, batch_size)\n@assert size(y.gf) == (DG, batch_size)\n\n\n\n\n\n","category":"type"},{"location":"#GraphNets.GNCoreList","page":"GraphNets.jl","title":"GraphNets.GNCoreList","text":"GNCoreList(input_dim, num_heads; head_size=(input_dim ÷ num_heads), dropout=0)\n\nInitializes an instance of the GNCoreList type, representing a sequence of GraphNet core blocks composed together.\n\nThe following keyword arguments are supported:\n\ndropout (Defaults to 0)\n\nA GNCoreList instance accepts an input array x of dimensions (C, T, B) and outputs an array of dimensions (HS, T, B). \"C\" is the channel size (embedding dimension). \"T\" is the block size (number of input tokens). \"B\" is the batch size.\n\nExamples:\n\ndims = (DE, DN, DG) = 3, 4, 5\ncore_list = GNCoreList([GNCore(dims), GNCore(dims)])\nadj_mat = adj_mat = [\n    1 0 1;\n    1 1 0;\n    0 0 1;\n]\nnum_nodes = size(adj_mat, 1)\nnum_edges = length(filter(isone, adj_mat))\nbatch_size = 2\nedge_features = rand(Float32, DE, num_edges, batch_size)\nnode_features = rand(Float32, DN, num_nodes, batch_size)\ngraph_features = rand(Float32, DG, batch_size)\nx = (\n    graphs=adj_mat, # All graphs in this batch have same structure\n    ef=edge_features, # (DE, num_edges, batch_size)\n    nf=node_features, # (DN, num_nodes, batch_size)\n    gf=graph_features # no input graph features\n) |> batch\ny = core_list(x) |> unbatch\n@assert size(y.ef) == (DE, num_edges, batch_size)\n@assert size(y.nf) == (DN, num_nodes, batch_size)\n@assert size(y.gf) == (DG, batch_size)\n\n\n\n\n\n","category":"type"},{"location":"#GraphNets.batch","page":"GraphNets.jl","title":"GraphNets.batch","text":"batch(t::NamedTuple)\n\nExample:\n\n    dims = (DE, DN, DG) = 3, 4, 5\n    core = GNCore(dims)\n    adj_mat_1 = [\n        1 0 1;\n        1 1 0;\n        0 0 1;\n    ] # Adjacency matrix 1\n    num_nodes_1 = size(adj_mat_1, 1)\n    num_edges_1 = length(filter(isone, adj_mat_1))\n    adj_mat_2 = [\n        1 0 1 0;\n        1 1 0 1;\n        0 0 1 0;\n        1 1 0 1;\n    ] # Adjacency matrix 2\n    num_nodes_2 = size(adj_mat_2, 1)\n    num_edges_2 = length(filter(isone, adj_mat_2))\n    edge_features = [\n        rand(Float32, DE, num_edges_1),\n        rand(Float32, DE, num_edges_2),\n    ]\n    node_features = [\n        rand(Float32, DN, num_nodes_1),\n        rand(Float32, DN, num_nodes_2),\n    ]\n    graph_features = [\n        rand(Float32, DG),\n        rand(Float32, DG),\n    ]\n    adj_mats = [adj_mat_1,adj_mat_2]\n    batch_size = length(adj_mats)\n    x = (\n        graphs=adj_mats,  # Graphs in this batch have different structure\n        ef=edge_features, \n        nf=node_features,\n        gf=graph_features\n    )\n    x_batched = batch(x)\n    edge_block_size = x_batched.graphs.edge_block_size\n    node_block_size = x_batched.graphs.node_block_size\n    @assert typeof(x_batched.graphs) == GraphNets.GNGraphBatch\n    @assert size(x_batched.ef) == (DE, edge_block_size, batch_size)\n    @assert size(x_batched.nf) == (DN, node_block_size, batch_size)\n    @assert size(x_batched.gf) == (DG, 1, batch_size)\n\n\n\n\n\n","category":"function"},{"location":"#GraphNets.unbatch","page":"GraphNets.jl","title":"GraphNets.unbatch","text":"unbatch(t::NamedTuple)\n\n\n\n\n\n","category":"function"},{"location":"#GraphNets.efview","page":"GraphNets.jl","title":"GraphNets.efview","text":"efview(t::NamedTuple, d1, d2, d3)\n\nReturns an array view of the edge features contained in the batched output.\n\n\n\n\n\n","category":"function"},{"location":"#GraphNets.nfview","page":"GraphNets.jl","title":"GraphNets.nfview","text":"nfview(t::NamedTuple, d1, d2, d3)\n\nReturns an array view of the noded features contained in the batched output.\n\n\n\n\n\n","category":"function"},{"location":"#GraphNets.gfview","page":"GraphNets.jl","title":"GraphNets.gfview","text":"gfview(t::NamedTuple, d1, d2)\n\nReturns an array view of the graph features contained in the batched output.\n\n\n\n\n\n","category":"function"}]
}
